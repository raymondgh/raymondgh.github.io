<!DOCTYPE html>
<meta charset="UTF-8">
<link rel="shortcut icon" href="/images/favicon.ico">
<body>
	open the console
</body>
<script>


//////////////////////
// Signaling Server //
//////////////////////

// keep track of who the server knows about
let listOfPeers = ['Peer1', 'Peer2'];
console.log("01. Our signaling server confirms that two peers exist");

// make sure signal won't crash the server
function parseSignal(rawSignal) {

	try {
		// parse the message as json (or at least try)
		let message = JSON.parse(rawSignal);

		// assuming we got json, make sure the destination is set as a peer on our list
		if (listOfPeers.includes(message.destination)) {

			// if destination is valid, let's dispatch it!
			processSignal(message);

		} else {

			// if destination not on list, let's just give up on this message :(
			console.log("SERVER: Uh oh, that destination isn't on our peer list. Let's just throw this message away!");
		}

	} catch(error) {

		// something failed earlier. probably parsing the json went poorly
		console.log("SERVER: Uh oh, we got a message that we couldn't parse. Let's just throw this message away!");
		console.log("But first, here's the error:", error);

	}
}


// signal is good enough to send, so now we stringify & send it!
function processSignal(message) {

	let payload = JSON.stringify(message);
	
	// simulate sending the message from server to client.
	switch (message.destination) {

		// these functions are how the peer handles signals from the server
		case 'Peer1':
			console.log("    The server sends the message to peer 1");
			peer1SignalHandler(payload);
			break;
		case 'Peer2':
			console.log("    The server sends the message to peer 2");
			peer2SignalHandler(payload);
			break;
		default:
			console.log("SERVER: Weird, a message was sent to the server and got past the validation but still has nowhere to go! Oh well.")
			console.log("Here's what it was:", message);
			break;
	}
}




////////////
// Peer 1 //
////////////

// begin by creating an RTCPeerConnection
let peer1connection = new RTCPeerConnection();
console.log("02. P1 creates a new RTCPeerConnection() object, peer1connection");


// we need a data channel (as opposed to video or audio) for this demo!
let peer1datachannel = peer1connection.createDataChannel('myFirstDataChannel')
console.log("03. P1 creates a data channel, peer1datachannel");

// now let's create an offer to send to peer2
peer1connection.createOffer().then((OfferRTCSessionDescription) => {

	console.log("06. P1 creates a connection offer, OfferRTCSessionDescription")

	// peer1, the offerer, will set the offer to be its Local Description
	// setting Local Description triggers the peer1connection.onicecandidate event!!
	peer1connection.setLocalDescription(OfferRTCSessionDescription);
	console.log("07. P1 sets its local description with this offer")


	// Prepare a message to send to peer 2
	let message = {	source: 'Peer1',
					destination: 'Peer2',
					messageType: 'data-offer',
					sessionDescription: OfferRTCSessionDescription
				};
	console.log("08. P1 sends the offer in a JSON with some metadata via the server")

	// send OfferRTCSessionDescription to peer2 via signaling server
	peer1SendMessageViaSignalingServer(message);
})


// function peer1 uses to pass messages to signaling server 
function peer1SendMessageViaSignalingServer(message) {

	// convert to string to send over our pretend network
	let payload = JSON.stringify(message)

	// server receives payload string. wow what great connection speed!
	parseSignal(payload);
}


// handle the onicecandidate events generated by setting of local description
peer1connection.onicecandidate = event => {

	// prepare a message to send to peer 2
	let message = { source: 'Peer1',
					destination: 'Peer2',
					messageType: 'ice-candidate',
					candidate: event.candidate
				};
	
	console.log("    ICE Candidate handled by P1 and sent via the server")
	peer1SendMessageViaSignalingServer(message);
}



// when the signaling server sends something to peer1, parse it and react
function peer1SignalHandler(signal) {

	message = JSON.parse(signal);

	switch (message.messageType) {

		case 'data-answer':
			// handle data offer
			peer1HandleDataAnswer(message);
			break;
		case 'ice-candidate':
			//handle ice candidate
			peer1HandleIceCandidate(message);
			break;
		default:
			console.log("PEER 1: We got something from the server but we don't know what it is!");
			console.log("Take a look for yourself:", signal);
	}
}


// handle ice candidate delivered by signal server from peer 2
function peer1HandleIceCandidate(message) {

	// get the candidate from the message
	let candidate = message.candidate;

	// add the ice candidate to the connection
	peer1connection.addIceCandidate(candidate).then(() =>

		// it worked!
		() => console.log('PEER 1: Yay, we added a candidate.'),

		// it didn't work!
		err => {
			console.log('PEER 1: Oh no! We failed to add the candidate');
			console.log("Here's the error:", err);
		});
}


// handle data offer delivered by signal server
function peer1HandleDataAnswer(message) {

	// set the remote description as the offer session description
	peer1connection.setRemoteDescription(message.sessionDescription);
	console.log("13. P1 sets the received answer as its remote description")
}




// some data channel handlers for peer 1
peer1datachannel.onopen = event => {
	console.log("14. Ice candidates from both peers match. P1's Data channel opened.");
}

peer1datachannel.onclose = event => {
	console.log("P1: Hey, my data channel was closed!");
}

peer1datachannel.onmessage = event => {
	console.log("P1: I just got this message:");
	console.log(event.data);
}



////////////
// Peer 2 //
////////////

let peer2connection = new RTCPeerConnection();
console.log("04. P2 creates a new RTCPeerConnection() object, peer2connection");


let peer2datachannel;
console.log("05. P2 creates a placeholder data channel, peer2datachannel");


// when the signaling server sends something to peer2, parse it and react
function peer2SignalHandler(signal) {

	message = JSON.parse(signal);

	switch (message.messageType) {

		case "data-offer":
			// handle data offer
			peer2HandleDataOffer(message);
			break;
		case 'ice-candidate':
			//handle ice candidate
			peer2HandleIceCandidate(message);
			break;
		default:
			console.log("P2: We got something from the server but we don't know what it is!");
			console.log("Take a look for yourself:", signal);
	}
}


// handle data offer delivered by signal server
function peer2HandleDataOffer(message) {

	// set the remote description as the offer session description
	peer2connection.setRemoteDescription(message.sessionDescription);
	console.log("09. P2 sets the received offer as its remote description")

	// create an answer to send back to peer 1 via the signaling server
	peer2connection.createAnswer().then((AnswerRTCSessionDescription) => {
	console.log("10. P2 creates a connection answer, AnswerRTCSessionDescription")


		// set the localdescription as the answer
		// setting Local Description triggers the peer2connection.onicecandidate event!!
		peer2connection.setLocalDescription(AnswerRTCSessionDescription);
		console.log("11. P2 sets the answer as its local description")


		// Prepare a message to send to peer 2
		let message = {	source: 'Peer2',
						destination: 'Peer1',
						messageType: 'data-answer',
						sessionDescription: AnswerRTCSessionDescription
					};
		
		console.log("12. P2 sends the answer in a JSON with some metadata via the server")

		// send AnswerRTCSessionDescription to peer1 via signaling server
		peer2SendMessageViaSignalingServer(message)
	});
}


// handle ice candidate delivered by signal server from peer 1
function peer2HandleIceCandidate(message) {

	// get the candidate from the message
	let candidate = message.candidate;

	// add the ice candidate to the connection
	peer2connection.addIceCandidate(candidate).then(() =>

		// it worked!
		() => console.log('P2: Yay, we added a candidate.'),

		// it didn't work!
		err => {
			console.log('P2: Oh no! We failed to add the candidate');
			console.log("Here's the error:", err);
		});
}


// handle the onicecandidate events generated by setting of local description
peer2connection.onicecandidate = event => {

	// prepare a message to send to peer 2
	let message = { source: 'Peer2',
					destination: 'Peer1',
					messageType: 'ice-candidate',
					candidate: event.candidate
				};
	console.log("    ICE Candidate handled by P2 and sent via the server")

	peer2SendMessageViaSignalingServer(message);
}



// function peer2 uses to pass messages to signaling server 
function peer2SendMessageViaSignalingServer(message) {

	// convert to string to send over our pretend network
	let payload = JSON.stringify(message)

	// server receives payload string. wow what great connection speed!
	parseSignal(payload);
}

// once data channel is created by peer1, peer2 should do something about it
peer2connection.ondatachannel = event => {

	// create data channel object for peer 2
	peer2datachannel = event.channel;

	// some data channel handlers for peer 1
	peer2datachannel.onopen = event => {
		console.log("15. P2's data channel is opened");
		console.log("16. All set! try the following commands:");
		console.log("    peer1datachannel.send('Hi friend')");
		console.log("    peer2datachannel.send('Hi pal')");
	}

	peer2datachannel.onclose = event => {
		console.log("P2: Hey, my data channel was closed!");
	}

	peer2datachannel.onmessage = event => {
		console.log("P2: I just got this message:");
		console.log(event.data);
	}


}

</script>
</html>